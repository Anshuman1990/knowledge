1
00:00:05,150 --> 00:00:06,610
Hello and welcome back.

2
00:00:06,690 --> 00:00:09,980
In this lecture I'd like to talk about the advantages of design patterns

3
00:00:13,790 --> 00:00:17,310
so why do we use design patterns.

4
00:00:17,580 --> 00:00:23,480
Most commonly stated reasons for studying and utilizing design patterns are because they enable us to

5
00:00:23,480 --> 00:00:24,650
do the following

6
00:00:28,170 --> 00:00:32,580
they have they provide the best solutions for certain problems faced during soft development.

7
00:00:32,610 --> 00:00:37,520
So I mentioned this quite a lot in the last lecture but it's important point to remember common problems

8
00:00:37,520 --> 00:00:42,810
conference of software solutions and what this basically does is it enables software reuse software

9
00:00:42,810 --> 00:00:44,310
reuse is incredibly important.

10
00:00:45,270 --> 00:00:51,810
If we can reuse existing solutions it will save time and time is a big deal when you're writing code

11
00:00:52,470 --> 00:00:56,850
so it makes it easier to reuse successful designs designs and architecture software reuse is one of

12
00:00:56,850 --> 00:00:58,350
the biggest advantages.

13
00:00:58,350 --> 00:01:00,690
That's why we really want to use them.

14
00:01:00,870 --> 00:01:02,840
The solutions have been tried and tested.

15
00:01:02,880 --> 00:01:08,280
They're going to work experienced developers have come up with the solutions so they're going to work

16
00:01:08,370 --> 00:01:13,380
and things that you know and you have confidence in working is a tremendous advantage.

17
00:01:13,380 --> 00:01:19,020
Learning these patterns helps unexperienced developers learn software design in an easy and faster way

18
00:01:24,920 --> 00:01:28,190
now that they're documented and they're out there for studying.

19
00:01:28,400 --> 00:01:30,960
You get the benefit of learning from other people.

20
00:01:31,070 --> 00:01:36,410
You get a head start on problems that you can avoid as a new and new design new developer.

21
00:01:36,890 --> 00:01:42,260
If you know that people encounter these problems and they have solutions form you you don't have to

22
00:01:42,260 --> 00:01:44,810
waste your time trying to figure it out.

23
00:01:45,050 --> 00:01:47,670
So it helps you avoid reinventing the wheel.

24
00:01:47,690 --> 00:01:55,190
A big big advantage you also use design patterns to basically understand object oriented principles

25
00:01:55,370 --> 00:01:57,510
that achieve high quality design.

26
00:01:57,620 --> 00:02:00,710
You do not want to just write code just to get the correct output.

27
00:02:00,710 --> 00:02:03,300
You want to make sure that your code is easily maintainable.

28
00:02:03,380 --> 00:02:10,100
You can achieve that by writing high quality code high quality code is highly dependent on high quality

29
00:02:10,100 --> 00:02:11,380
design.

30
00:02:11,480 --> 00:02:17,170
So this includes keeping classes separated preventing them from having to know too much about one another.

31
00:02:17,170 --> 00:02:21,430
All right this concept of coupling you don't want to have a lot of dependencies between classes.

32
00:02:21,440 --> 00:02:26,070
It'd be really nice if the class is very highly cohesive it does since it has a single focus inside

33
00:02:26,100 --> 00:02:27,010
its own.

34
00:02:27,020 --> 00:02:30,900
You can take it out you can remove it and it doesn't cause all sorts of problems.

35
00:02:30,920 --> 00:02:37,040
So these three concepts that are important in high quality design are encapsulation inheritance polymorphism

36
00:02:37,520 --> 00:02:40,870
in design patterns heavily use these concepts.

37
00:02:40,880 --> 00:02:45,680
It may not be direct inheritance maybe inheritance through interfaces but these are really important

38
00:02:45,680 --> 00:02:46,490
things.

39
00:02:46,490 --> 00:02:48,840
And this is why you want to study design patterns.

40
00:02:48,860 --> 00:02:53,420
You don't reinvent the wheel and you don't have to and it makes you become a very very high quality

41
00:02:53,420 --> 00:02:55,970
programmer and a high quality designer.

42
00:02:56,150 --> 00:02:59,750
You're gonna be one of the best out there coming up with solutions.

43
00:02:59,810 --> 00:03:04,640
Your employer or subsequent employees employers are gonna want to hire you because you know what you're

44
00:03:04,640 --> 00:03:08,120
doing because you're focusing on high quality.

45
00:03:08,270 --> 00:03:10,640
So this is why we use design patterns.

46
00:03:10,700 --> 00:03:16,520
We also use them because it improves communication either amongst your team or just code developers

47
00:03:16,520 --> 00:03:18,290
you're working with on other teams.

48
00:03:18,530 --> 00:03:20,170
You have this common platform right.

49
00:03:20,180 --> 00:03:24,830
We talked about design patents and what they do and how they have a name a description a problem.

50
00:03:24,950 --> 00:03:29,540
You can easily talk to your co-workers and say hey what do you think of the adapter in this in this

51
00:03:30,170 --> 00:03:31,520
particularly situation.

52
00:03:31,520 --> 00:03:33,150
Yeah I think that's a good solution.

53
00:03:33,200 --> 00:03:34,090
So it's good provide.

54
00:03:34,100 --> 00:03:39,470
It provides a good com point of reference during the analysis and design phase of a project.

55
00:03:39,560 --> 00:03:44,570
It allows you to describe your programming approach succinctly in terms that other programs can easily

56
00:03:44,570 --> 00:03:45,340
understand.

57
00:03:45,380 --> 00:03:49,760
You just throw around these words and it really speeds up the process.

58
00:03:49,850 --> 00:03:52,970
So program is conferred a program that uses a single object as a singleton.

59
00:03:52,970 --> 00:03:55,250
Hey hey Mike I need to use a singleton.

60
00:03:55,400 --> 00:03:57,310
Oh he knows exactly what you mean.

61
00:03:57,340 --> 00:03:59,290
Oh Singleton you only need to create one instance.

62
00:03:59,330 --> 00:03:59,790
All right.

63
00:03:59,810 --> 00:04:01,310
I use that before.

64
00:04:01,310 --> 00:04:03,040
That's a great solution.

65
00:04:03,500 --> 00:04:08,930
More on inexperienced junior team members can see that the senior developers who know the design patterns

66
00:04:09,260 --> 00:04:12,990
have something of value it makes them want to learn from you.

67
00:04:13,100 --> 00:04:13,350
Right.

68
00:04:13,370 --> 00:04:17,610
So the junior members will respect you more they'll ask you for help but want to learn from you.

69
00:04:17,660 --> 00:04:25,190
So provides motivation and it really really helps more low or low level or inexperienced programmers

70
00:04:25,940 --> 00:04:31,130
become better programmers by learning these powerful concepts.

71
00:04:31,130 --> 00:04:35,080
It also gives a higher perspective on the problem at a higher level.

72
00:04:35,210 --> 00:04:41,300
Again concerning design and object oriented analysis and design I don't go into analysis it is really

73
00:04:41,300 --> 00:04:46,970
a tough thing to understand you know analyze requirements come up with a really suitable design and

74
00:04:47,030 --> 00:04:53,540
if you can have that high perspective by understanding design patterns it's going to again it because

75
00:04:54,020 --> 00:04:56,940
abstraction is such a big deal when it comes to design patterns.

76
00:04:57,050 --> 00:05:01,850
You don't have to worry about the details too early when you look at a design pattern you understand

77
00:05:01,850 --> 00:05:04,760
them and you're now trying to solve a problem.

78
00:05:04,880 --> 00:05:11,900
You can take a step back so helps a designer get a design that is correct and of high quality much faster

79
00:05:12,170 --> 00:05:19,120
than it was in the past without using design patterns it improves modify ability and maintain ability

80
00:05:19,120 --> 00:05:20,100
of code.

81
00:05:20,140 --> 00:05:25,930
What this means is you can actually change the code much easier without breaking everything you can

82
00:05:25,930 --> 00:05:31,060
find and fix bugs much easier because if you use a design pattern that design pattern is very loosely

83
00:05:31,060 --> 00:05:35,990
coupled and so it's going to it's a very high cohesive code so you're going to be able to find a fix

84
00:05:35,990 --> 00:05:41,090
bugs easier and get coupling and cohesion I've used those terms we'll talk about in more detail but

85
00:05:41,480 --> 00:05:47,030
those are really important terms to understand when you have time tested solutions that have evolved

86
00:05:47,030 --> 00:05:52,330
into structures that can handle change more readily than will often first comes to mind as a solution.

87
00:05:52,370 --> 00:05:54,620
So you have to be able to change things.

88
00:05:54,650 --> 00:05:56,800
Software is constantly evolving.

89
00:05:56,870 --> 00:06:02,960
It's constantly changing and you have all these other team members or other developers modifying that

90
00:06:02,960 --> 00:06:03,350
code.

91
00:06:03,380 --> 00:06:06,800
If it's hard to change something it's gonna be a nightmare.

92
00:06:06,800 --> 00:06:14,570
So making the code easily changeable is going to be a big huge deal and design patterns allow that because

93
00:06:14,570 --> 00:06:19,910
the improved documentation results from the common terminology people.

94
00:06:19,970 --> 00:06:23,330
Again I mentioned this before but it's improved communication.

95
00:06:23,610 --> 00:06:29,460
The code is much easier to understand much easier to maintain because of these great patterns and solutions.

96
00:06:29,570 --> 00:06:31,240
So that's why we use design patterns.

97
00:06:31,240 --> 00:06:33,170
All right.

98
00:06:33,370 --> 00:06:36,980
You know really really important there to understand that if you don't understand why you're using them

99
00:06:36,980 --> 00:06:39,870
why you're studying them shouldn't really be in this course.

100
00:06:39,890 --> 00:06:43,670
It provides high quality solutions improves maintenance.

101
00:06:43,670 --> 00:06:47,320
Much easier to find bugs fixed problems.

102
00:06:47,390 --> 00:06:50,350
What specific problems are addressed by design patterns.

103
00:06:50,600 --> 00:06:55,430
Well they solve many of the day to day problems object oriented designers face in and they solve them

104
00:06:55,430 --> 00:06:57,290
in many different ways.

105
00:06:57,380 --> 00:07:02,900
So how do a data fire the appropriate objects to utilize or create one thing when you first are writing

106
00:07:02,900 --> 00:07:08,090
code and you first first start coming up with some kind of solution or design is an object oriented

107
00:07:08,090 --> 00:07:12,340
language you ask yourself what objects should I include in the system.

108
00:07:12,440 --> 00:07:15,880
And a lot of times you're you're you know you dump on you don't know where to start.

109
00:07:15,950 --> 00:07:22,460
Some classes may tell you OK well describe the system in terms of you know a narrative paragraph and

110
00:07:22,460 --> 00:07:28,400
then identify the nouns the nouns are going to be your objects but really the best way to understand

111
00:07:28,400 --> 00:07:32,660
what objects are appropriate for a given situation is through experience and through learning design

112
00:07:32,660 --> 00:07:38,570
patterns they greatly help identify objects and such because basically they're documented they tell

113
00:07:38,570 --> 00:07:40,500
you exactly what objects you need.

114
00:07:40,980 --> 00:07:46,040
So object packages both data and the procedures that operate on that data it's a problem that you have

115
00:07:46,040 --> 00:07:51,360
to identify and can help with design patterns how to specify object interfaces.

116
00:07:51,360 --> 00:07:51,550
All right.

117
00:07:51,560 --> 00:07:58,700
We all know what an interfaces its contract basically between a client and somebody that wants to use

118
00:07:58,700 --> 00:08:06,740
that and the interface itself interfaces are really really advantageous because they provide this abstraction

119
00:08:07,250 --> 00:08:09,740
and they allow for isolation.

120
00:08:09,740 --> 00:08:15,430
So when you come up with and how to identify an interface that's a problem that you face in design patterns

121
00:08:15,440 --> 00:08:21,440
can help with this every operation declared by an object specifies the operations name the object takes

122
00:08:21,470 --> 00:08:24,250
as parameters and the operations return value.

123
00:08:24,320 --> 00:08:26,680
This makes it very easy to create the interface.

124
00:08:26,960 --> 00:08:30,470
So the interface characterizes the complete set of requests that can be sent to the object

125
00:08:33,770 --> 00:08:35,700
how to specify object implementations right.

126
00:08:35,710 --> 00:08:38,010
We've come up with the objects in the system.

127
00:08:38,090 --> 00:08:40,180
We understand what interfaces we need.

128
00:08:40,250 --> 00:08:42,820
Now we need to actually go and implement.

129
00:08:42,880 --> 00:08:46,440
Well this is a common problem obviously implementing solutions.

130
00:08:46,490 --> 00:08:49,120
The implementation is defined design defined by the class.

131
00:08:49,130 --> 00:08:54,440
You know that and it specifies the objects internal data and representation in defines the operations

132
00:08:55,160 --> 00:08:56,930
that the object can perform.

133
00:08:56,930 --> 00:09:04,430
All of these things are helped by understanding design patterns design patterns have high level implementation

134
00:09:05,480 --> 00:09:07,760
that are gonna are gonna be descriptive scribed.

135
00:09:07,760 --> 00:09:15,320
So these three problems are reduced and help a lot if you understand design patterns the multiple sets

136
00:09:15,560 --> 00:09:17,560
you have available for you to you.

137
00:09:17,570 --> 00:09:22,920
The easier it is going to be able to identify the objects specify the interfaces and do the actual implementation.

138
00:09:22,970 --> 00:09:28,280
It's all about making you a better program or a high quality programmer and design patterns we'll do

139
00:09:28,280 --> 00:09:30,880
that.

140
00:09:30,890 --> 00:09:35,760
Problems of dust by design parents again continued determining object granulated.

141
00:09:36,110 --> 00:09:41,650
So we know objects can be very large and you can have many many objects right.

142
00:09:41,660 --> 00:09:45,650
Usually the more objects you have the harder it is to maintain if the objects are not cohesive and they

143
00:09:45,650 --> 00:09:46,580
have a ton of code.

144
00:09:46,580 --> 00:09:51,130
Again hard to maintain design patterns will provide that granularity.

145
00:09:51,170 --> 00:09:55,220
They'll say how big should this object be how many objects should you have.

146
00:09:55,310 --> 00:10:00,410
So the granularity can include size and number it also can represent everything down to the hardware

147
00:10:00,410 --> 00:10:02,990
all the way up to the entire application.

148
00:10:03,110 --> 00:10:06,280
So design patterns address this granular issue.

149
00:10:06,500 --> 00:10:11,390
For example the facade pattern that we're going to learn about describes how you can represent complete

150
00:10:11,390 --> 00:10:12,980
subsystems as objects.

151
00:10:12,980 --> 00:10:17,470
So right there it's going to tell you this is how many objects you need for this subsystem the away

152
00:10:17,480 --> 00:10:19,580
pattern we're going to.

153
00:10:19,580 --> 00:10:23,710
It will describe how to support huge number of objects at the finest granularity.

154
00:10:24,890 --> 00:10:29,950
Abstract Factory and builder are going to yield objects whose only responsibilities are creating other

155
00:10:29,950 --> 00:10:31,290
objects right.

156
00:10:31,290 --> 00:10:33,370
That's a level of granularity.

157
00:10:33,370 --> 00:10:34,990
How do I create this object.

158
00:10:34,990 --> 00:10:40,690
They identify that they have a common solution for that the visitor in the command will yield objects

159
00:10:40,690 --> 00:10:46,120
was only responsibilities are to implement a request on another object or group of objects so they have

160
00:10:46,120 --> 00:10:53,260
a single responsibility they're highly cohesive right in and again allows it easier to maintain the

161
00:10:53,260 --> 00:10:54,640
design in the code.

162
00:10:54,760 --> 00:10:59,280
To summarise design patterns advantages right.

163
00:11:00,040 --> 00:11:06,970
They allow for software reuse where you reuse these high quality solutions to commonly recurring problems.

164
00:11:06,970 --> 00:11:10,640
They also establish common terminology to improve communications with teams.

165
00:11:10,780 --> 00:11:15,910
We've talked about that they shift the level of thinking to a hiring perspective you don't get bogged

166
00:11:15,910 --> 00:11:20,320
down in the details when you're trying to solve a problem you first look at at a high level and then

167
00:11:20,320 --> 00:11:23,850
you try to solve it and you get down the details when you need to get down to the details.

168
00:11:24,310 --> 00:11:29,480
They decide whether you have the right design not just one that works right.

169
00:11:29,520 --> 00:11:33,350
It's a high quality design again because it's been tried and tested.

170
00:11:33,430 --> 00:11:37,820
It's the right design for that problem or for that situation.

171
00:11:37,900 --> 00:11:42,050
Design Patterns also improve individual learning and team learning.

172
00:11:42,130 --> 00:11:45,910
You can learn things quicker by understanding these concepts.

173
00:11:46,300 --> 00:11:49,910
It improves the modifiable ability quality of code.

174
00:11:50,050 --> 00:11:51,920
Code is constantly changing.

175
00:11:52,000 --> 00:11:57,670
If the code is so tightly coupled and it's so hard to change every time you need to add something new

176
00:11:57,700 --> 00:11:59,290
you're gonna break everything.

177
00:11:59,290 --> 00:12:04,720
So if you can make your code adaptable to change it's going to be a big deal in design parents like

178
00:12:04,720 --> 00:12:06,060
to do that.

179
00:12:06,340 --> 00:12:11,170
They facilitate adoption of improved design alternatives even when patterns are not used explicitly.

180
00:12:11,170 --> 00:12:15,400
So because of your knowledge base and because of the different solutions you have it allows you to come

181
00:12:15,400 --> 00:12:19,240
up with other solutions other alternatives.

182
00:12:19,240 --> 00:12:24,670
They discover alternatives to large inheritance hierarchy so it allows you to avoid using these gigantic

183
00:12:24,670 --> 00:12:28,450
inheritance hierarchies that a lot of developers tend to overuse.

184
00:12:28,540 --> 00:12:34,080
You can avoid that through the use of your experience with design patterns up to this point.

185
00:12:34,090 --> 00:12:39,650
I've described a lot of theoretical approaches or through theoretical definitions design patterns.

186
00:12:39,700 --> 00:12:40,860
What is the design pattern.

187
00:12:40,870 --> 00:12:41,590
Why do we use it.

188
00:12:41,590 --> 00:12:42,940
What are the advantages.

189
00:12:42,940 --> 00:12:46,170
Soon we're gonna get into more practical solutions.

190
00:12:46,180 --> 00:12:53,230
I'm going to talk more about Java code and more about design examples or implementation examples.

191
00:12:53,230 --> 00:12:57,250
But again it's important early on to understand what you're studying.

192
00:12:57,280 --> 00:12:58,450
Why do you want to study it.

193
00:12:58,450 --> 00:12:59,830
Why is it important.

194
00:12:59,830 --> 00:13:05,110
So the advantages and the definitions the high level overview I think is necessary.

195
00:13:05,380 --> 00:13:10,660
If you're getting bored you can just jump right in to some coding examples and start right off with

196
00:13:10,660 --> 00:13:14,260
some of the upcoming lectures on specific design patterns.

197
00:13:14,260 --> 00:13:20,020
But if you really want to have a good while rounding rounded understanding of why you use design patterns

198
00:13:20,110 --> 00:13:23,090
and the principles and strategies that you employ please stick with me.

199
00:13:23,590 --> 00:13:23,950
Thank you.
